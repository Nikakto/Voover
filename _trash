def floodfill(image, color_matrix=COLOR_MATRIX):

    def _same_color(rgb_a, rgb_b, sensitive):
        m_a = sum(rgb_a[:3])/3
        m_b = sum(rgb_b[:3])/3
        return abs(m_a - m_b) < sensitive/2

    color_step = int(math.ceil(255 / (len(color_matrix) - 1)))

    # map of pixels
    pixel_bitmap = [[None] * image.height() for i in range(image.width())]

    # floodfilling
    for i in range(image.width()):
        print('line: %s/%s' % (i, image.width()))
        for j in range(image.height()):

            if pixel_bitmap[i][j]:
                continue

            floodfill_list = [(i, j)]
            floodfill_color = QColor(image.pixel(i, j)).getRgb()

            r, g, b = COLOR_MATRIX[random.randint(0, len(COLOR_MATRIX)-1)]
            floodfill_by_color = QColor(r, g, b).rgb()

            while floodfill_list:

                _x, _y = floodfill_list.pop()

                my_color = QColor(image.pixel(_x, _y)).getRgb()
                same_color = _same_color(floodfill_color, my_color, color_step)

                if pixel_bitmap[_x][_y] or not same_color:
                    continue

                pixel_bitmap[_x][_y] = floodfill_by_color

                if _x > 0 and pixel_bitmap[_x - 1][_y] is None:
                    floodfill_list.append((_x - 1, _y))

                if _x < image.width()-1 and pixel_bitmap[_x+1][_y] is None:
                    floodfill_list.append((_x+1, _y))

                if _y > 0 and pixel_bitmap[_x][_y - 1] is None:
                    floodfill_list.append((_x, _y - 1))

                if _y < image.height()-1 and pixel_bitmap[_x][_y + 1] is None:
                    floodfill_list.append((_x, _y + 1))

    for i in range(image.width()):
        print('apply color: %s/%s' % (i, image.width()))
        for j in range(image.height()):
            if pixel_bitmap[i][j]:
                image.setPixel(QPoint(i, j), pixel_bitmap[i][j])

    return image